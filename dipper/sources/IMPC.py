import csv
import gzip
import re
import logging
import os

from dipper.sources.Source import Source
from dipper.models.Genotype import Genotype
from dipper.models.assoc.G2PAssoc import G2PAssoc
from dipper.models.Evidence import Evidence
from dipper.models.Provenance import Provenance
from dipper.models.Model import Model

LOG = logging.getLogger(__name__)
# temp? detour
# IMPCDL = 'ftp://ftp.ebi.ac.uk/pub/databases/impc/latest/csv'
# through stopgap
IMPCDL = 'ftp://ftp.ebi.ac.uk/pub/databases/impc/release-8.0/csv'
GITHUBRAW = 'https://raw.githubusercontent.com/'


class IMPC(Source):
    """
    From the [IMPC](http://mousephenotype.org) website:
    The IMPC is generating a knockout mouse strain for every protein coding
    gene by using the embryonic stem cell resource generated by the
    International Knockout Mouse Consortium (IKMC).
    Systematic broad-based phenotyping is performed by each IMPC center using
    standardized procedures found within the
    International Mouse Phenotyping Resource of Standardised Screens (IMPReSS)
    resource. Gene-to-phenotype associations are made by a versioned
    statistical analysis with all data freely available by this web portal and
    by several data download features.

    Here, we pull the data and model the genotypes using GENO and the
    genotype-to-phenotype associations using the OBAN schema.

    We use all identifiers given by the IMPC with a few exceptions:

    *  For identifiers that IMPC provides, but does not resolve,
    we instantiate them as Blank Nodes.
    Examples include things with the pattern of: UROALL, EUROCURATE, NULL-*,

    *  We mint three identifiers:
    1.  Intrinsic genotypes not including sex, based on:
     * colony_id (ES cell line + phenotyping center)
     * strain
     * zygosity

    2.  For the Effective genotypes that are attached to the phenotypes:
     * colony_id (ES cell line + phenotyping center)
     * strain
     * zygosity
     * sex

    3.  Associations based on:
    effective_genotype_id + phenotype_id + phenotyping_center +
    pipeline_stable_id + procedure_stable_id + parameter_stable_id

    We DO NOT yet add the assays as evidence for the G2P associations here.
    To be added in the future.

    """

    files = {
        # 'impc': {
        #   'file': 'IMPC_genotype_phenotype.csv.gz',
        #   'url': IMPCDL + '/IMPC_genotype_phenotype.csv.gz'},
        # 'euro': {
        #   'file': 'EuroPhenome_genotype_phenotype.csv.gz',
        #   'url': IMPCDL + '/EuroPhenome_genotype_phenotype.csv.gz'},
        # 'mgd': {
        #   'file': 'MGP_genotype_phenotype.csv.gz',
        #   'url': IMPCDL + '/MGP_genotype_phenotype.csv.gz'},
        # '3i': {
        #   'file': '3I_genotype_phenotype.csv.gz',
        #   'url': IMPCDL + '/3I_genotype_phenotype.csv.gz'},
        'all': {
            'file': 'ALL_genotype_phenotype.csv.gz',
            'url': IMPCDL + '/ALL_genotype_phenotype.csv.gz',
            'columns': [  # head -1 | tr ',' '\n' | sed "s|\(.*\)|'\1',|g"
                'marker_accession_id',
                'marker_symbol',
                'phenotyping_center',
                'colony_id',
                'sex',
                'zygosity',
                'allele_accession_id',
                'allele_symbol',
                'allele_name',
                'strain_accession_id',
                'strain_name',
                'project_name',
                'project_fullname',
                'pipeline_name',
                'pipeline_stable_id',
                'procedure_stable_id',
                'procedure_name',
                'parameter_stable_id',
                'parameter_name',
                'top_level_mp_term_id',
                'top_level_mp_term_name',
                'mp_term_id',
                'mp_term_name',
                'p_value',
                'percentage_change',
                'effect_size',
                'statistical_method',
                'resource_name'
            ]
        },
        'checksum': {
            'file': 'checksum.md5',
            'url': IMPCDL + '/checksum.md5'},
    }

    def __init__(self,
                 graph_type,
                 are_bnodes_skolemized,
                 data_release_version=None):
        super().__init__(
            graph_type=graph_type,
            are_bnodes_skized=are_bnodes_skolemized,
            data_release_version=data_release_version,
            name='impc',
            ingest_title='International Mouse Phenotyping Consortium',
            ingest_url='http://www.mousephenotype.org',
            ingest_logo='source-impc.png',
            license_url=None,
            data_rights=GITHUBRAW + 'mpi2/PhenotypeArchive/master/LICENSE',
            file_handle=None
        )

        # TODO add a citation for impc dataset as a whole
        # :impc cito:citesAsAuthority PMID:24194600
        # self.dataset.citation()

        if 'mouse' in self.all_test_ids:
            self.gene_ids = self.all_test_ids['mouse']
        else:
            LOG.warning("not configured with gene test ids.")
            self.gene_ids = []

    def fetch(self, is_dl_forced=False):
        self.get_files(is_dl_forced)
        LOG.info("Verifying checksums...")
        if self.compare_checksums():
            LOG.debug('Files have same checksum as reference')
        else:
            raise Exception('Reference checksums do not match disk')

    def parse(self, limit=None):
        """
        IMPC data is delivered in three separate csv files OR
        in one integrated file, each with the same file format.

        :param limit:
        :return:

        """
        if limit is not None:
            LOG.info("Only parsing first %s rows fo each file", str(limit))

        LOG.info("Parsing files...")

        if self.test_only:
            self.test_mode = True

        # for f in ['impc', 'euro', 'mgd', '3i']:
        for src_key in ['all']:
            file = '/'.join((self.rawdir, self.files[src_key]['file']))
            self._process_data(file, limit)
        LOG.info("Finished parsing")

    def _process_data(self, raw, limit=None):
        LOG.info("Processing Data from %s", raw)

        if self.test_mode:
            graph = self.testgraph
        else:
            graph = self.graph
        model = Model(graph)
        geno = Genotype(graph)

        # Add the taxon as a class
        taxon_id = self.globaltt['Mus musculus']
        model.addClassToGraph(taxon_id, None)

        # with open(raw, 'r', encoding="utf8") as csvfile:
        col = self.files['all']['columns']
        with gzip.open(raw, 'rt') as csvfile:
            reader = csv.reader(csvfile, delimiter=',', quotechar='\"')
            row = next(reader)  # presumed header
            if not self.check_fileheader(col, row):
                pass

            for row in reader:
                # | head -1 | tr ',' '\n' | sed "s|\(.*\)|# \1 = row[col.index('\1')]|g"
                marker_accession_id = row[col.index('marker_accession_id')].strip()
                marker_symbol = row[col.index('marker_symbol')].strip()
                phenotyping_center = row[col.index('phenotyping_center')].strip()
                colony_raw = row[col.index('colony_id')].strip()
                sex = row[col.index('sex')].strip()
                zygosity = row[col.index('zygosity')].strip()
                allele_accession_id = row[col.index('allele_accession_id')].strip()
                allele_symbol = row[col.index('allele_symbol')].strip()
                # allele_name = row[col.index('allele_name')]
                strain_accession_id = row[col.index('strain_accession_id')].strip()
                strain_name = row[col.index('strain_name')].strip()
                # project_name = row[col.index('project_name')]
                project_fullname = row[col.index('project_fullname')].strip()
                pipeline_name = row[col.index('pipeline_name')].strip()
                pipeline_stable_id = row[col.index('pipeline_stable_id')].strip()
                procedure_stable_id = row[col.index('procedure_stable_id')].strip()
                procedure_name = row[col.index('procedure_name')].strip()
                parameter_stable_id = row[col.index('parameter_stable_id')].strip()
                parameter_name = row[col.index('parameter_name')].strip()
                # top_level_mp_term_id = row[col.index('top_level_mp_term_id')]
                # top_level_mp_term_name = row[col.index('top_level_mp_term_name')]
                mp_term_id = row[col.index('mp_term_id')].strip()
                mp_term_name = row[col.index('mp_term_name')].strip()
                p_value = row[col.index('p_value')].strip()
                percentage_change = row[col.index('percentage_change')].strip()
                effect_size = row[col.index('effect_size')].strip()
                statistical_method = row[col.index('statistical_method')].strip()
                resource_name = row[col.index('resource_name')].strip()

                if self.test_mode and marker_accession_id not in self.gene_ids:
                    continue

                # ##### cleanup some of the identifiers ######
                zygosity = zygosity.strip()
                zygosity_id = self.resolve(zygosity)
                if zygosity_id == zygosity:
                    LOG.warning(
                        "Zygosity '%s' unmapped. detting to indeterminate", zygosity)
                    zygosity_id = self.globaltt['indeterminate']

                # colony ids sometimes have <> in them, spaces,
                # or other non-alphanumerics and break our system;
                # replace these with underscores
                colony_id = '_:' + re.sub(r'\W+', '_', colony_raw)

                if not re.match(r'MGI', allele_accession_id):
                    allele_accession_id = '_:IMPC-'+re.sub(
                        r':', '', allele_accession_id)

                if re.search(r'EUROCURATE', strain_accession_id):
                    # the eurocurate links don't resolve at IMPC
                    # TODO blank nodes do not maintain identifiers
                    strain_accession_id = '_:' + strain_accession_id

                elif not re.match(r'MGI', strain_accession_id):
                    LOG.info(
                        "Found a strange strain accession...%s", strain_accession_id)
                    strain_accession_id = 'IMPC:'+strain_accession_id

                ######################
                # first, add the marker and variant to the graph as with MGI,
                # the allele is the variant locus.  IF the marker is not known,
                # we will call it a sequence alteration.  otherwise,
                # we will create a BNode for the sequence alteration.
                sequence_alteration_id = variant_locus_id = None
                variant_locus_name = sequence_alteration_name = None

                # extract out what's within the <> to get the symbol
                if re.match(r'.*<.*>', allele_symbol):
                    sequence_alteration_name = re.match(
                        r'.*<(.*)>', allele_symbol)
                    if sequence_alteration_name is not None:
                        sequence_alteration_name = sequence_alteration_name.group(1)
                else:
                    sequence_alteration_name = allele_symbol

                if marker_accession_id is not None and marker_accession_id == '':
                    LOG.warning("Marker unspecified on row %d", reader.line_num)
                    marker_accession_id = None

                if marker_accession_id is not None:
                    variant_locus_id = allele_accession_id
                    variant_locus_name = allele_symbol
                    variant_locus_type = self.globaltt['variant_locus']
                    geno.addGene(
                        marker_accession_id, marker_symbol, self.globaltt['gene'])

                    geno.addAllele(
                        variant_locus_id, variant_locus_name, variant_locus_type, None)
                    geno.addAlleleOfGene(variant_locus_id, marker_accession_id)

                    # TAG bnode
                    sequence_alteration_id = '_:seqalt' + re.sub(
                        r':', '', allele_accession_id)
                    geno.addSequenceAlterationToVariantLocus(
                        sequence_alteration_id, variant_locus_id)

                else:
                    sequence_alteration_id = allele_accession_id

                # IMPC contains targeted mutations with either gene traps,
                # knockouts, insertion/intragenic deletions.
                # but I don't really know what the SeqAlt is here,
                # so I don't add it.
                geno.addSequenceAlteration(
                    sequence_alteration_id, sequence_alteration_name)

                # #############    BUILD THE COLONY    #############
                # First, let's describe the colony that the animals come from
                # The Colony ID refers to the ES cell clone
                #   used to generate a mouse strain.
                # Terry sez: we use this clone ID to track
                #   ES cell -> mouse strain -> mouse phenotyping.
                # The same ES clone maybe used at multiple centers,
                # so we have to concatenate the two to have a unique ID.
                # some useful reading about generating mice from ES cells:
                # http://ki.mit.edu/sbc/escell/services/details

                # here, we'll make a genotype
                # that derives from an ES cell with a given allele.
                # the strain is not really attached to the colony.

                # the colony/clone is reflective of the allele,  with unknown zygosity

                stem_cell_class = self.globaltt['embryonic stem cell line']

                if colony_id is None:
                    print(colony_raw, stem_cell_class, "\nline:\t", reader.line_num)
                model.addIndividualToGraph(colony_id, colony_raw, stem_cell_class)

                # vslc of the colony has unknown zygosity
                # note that we will define the allele
                # (and it's relationship to the marker, etc.) later
                # FIXME is it really necessary to create this vslc
                # when we always know it's unknown zygosity?
                vslc_colony = '_:'+re.sub(
                    r':', '', allele_accession_id + self.globaltt['indeterminate'])
                vslc_colony_label = allele_symbol + '/<?>'
                # for ease of reading, we make the colony genotype variables.
                # in the future, it might be desired to keep the vslcs
                colony_genotype_id = vslc_colony
                colony_genotype_label = vslc_colony_label
                geno.addGenotype(colony_genotype_id, colony_genotype_label)
                geno.addParts(
                    allele_accession_id, colony_genotype_id,
                    self.globaltt['has_variant_part'])

                geno.addPartsToVSLC(
                    vslc_colony, allele_accession_id, None,
                    self.globaltt['indeterminate'], self.globaltt['has_variant_part'])
                graph.addTriple(
                    colony_id, self.globaltt['has_genotype'], colony_genotype_id)

                # ##########    BUILD THE ANNOTATED GENOTYPE    ##########
                # now, we'll build the genotype of the individual that derives
                # from the colony/clone genotype that is attached to
                # phenotype = colony_id + strain + zygosity + sex
                # (and is derived from a colony)

                # this is a sex-agnostic genotype
                genotype_id = self.make_id(
                    (colony_id + phenotyping_center + zygosity + strain_accession_id))
                geno.addSequenceDerivesFrom(genotype_id, colony_id)

                # build the VSLC of the sex-agnostic genotype
                # based on the zygosity
                allele1_id = allele_accession_id
                allele2_id = allele2_rel = None
                allele1_label = allele_symbol
                allele2_label = '<?>'
                # Making VSLC labels from the various parts,
                # can change later if desired.
                if zygosity == 'heterozygote':
                    allele2_label = re.sub(r'<.*', '<+>', allele1_label)
                    allele2_id = None
                elif zygosity == 'homozygote':
                    allele2_label = allele1_label
                    allele2_id = allele1_id
                    allele2_rel = self.globaltt['has_variant_part']
                elif zygosity == 'hemizygote':
                    allele2_label = re.sub(r'<.*', '<0>', allele1_label)
                    allele2_id = None
                elif zygosity == 'not_applicable':
                    allele2_label = re.sub(r'<.*', '<?>', allele1_label)
                    allele2_id = None
                else:
                    LOG.warning("found unknown zygosity %s", zygosity)
                    break
                vslc_name = '/'.join((allele1_label, allele2_label))

                # Add the VSLC
                vslc_id = '-'.join(
                    (marker_accession_id, allele_accession_id, zygosity))
                vslc_id = re.sub(r':', '', vslc_id)
                vslc_id = '_:'+vslc_id
                model.addIndividualToGraph(
                    vslc_id, vslc_name,
                    self.globaltt['variant single locus complement'])
                geno.addPartsToVSLC(
                    vslc_id, allele1_id, allele2_id, zygosity_id,
                    self.globaltt['has_variant_part'], allele2_rel)

                # add vslc to genotype
                geno.addVSLCtoParent(vslc_id, genotype_id)

                # note that the vslc is also the gvc
                model.addType(vslc_id, self.globaltt['genomic_variation_complement'])

                # Add the genomic background
                # create the genomic background id and name
                if strain_accession_id != '':
                    genomic_background_id = strain_accession_id
                else:
                    genomic_background_id = None

                genotype_name = vslc_name
                if genomic_background_id is not None:
                    geno.addGenotype(
                        genomic_background_id, strain_name,
                        self.globaltt['genomic_background'])

                    # make a phenotyping-center-specific strain
                    # to use as the background
                    pheno_center_strain_label = strain_name + '-' + phenotyping_center \
                        + '-' + colony_raw
                    pheno_center_strain_id = '-'.join((
                        re.sub(r':', '', genomic_background_id),
                        re.sub(r'\s', '_', phenotyping_center),
                        re.sub(r'\W+', '', colony_raw)))
                    if not re.match(r'^_', pheno_center_strain_id):
                        # Tag bnode
                        pheno_center_strain_id = '_:' + pheno_center_strain_id

                    geno.addGenotype(
                        pheno_center_strain_id, pheno_center_strain_label,
                        self.globaltt['genomic_background'])
                    geno.addSequenceDerivesFrom(
                        pheno_center_strain_id, genomic_background_id)

                    # Making genotype labels from the various parts,
                    # can change later if desired.
                    # since the genotype is reflective of the place
                    # it got made, should put that in to disambiguate
                    genotype_name = \
                        genotype_name + ' [' + pheno_center_strain_label + ']'
                    geno.addGenomicBackgroundToGenotype(
                        pheno_center_strain_id, genotype_id)
                    geno.addTaxon(taxon_id, pheno_center_strain_id)
                # this is redundant, but i'll keep in in for now
                geno.addSequenceDerivesFrom(genotype_id, colony_id)
                geno.addGenotype(genotype_id, genotype_name)

                # Make the sex-qualified genotype,
                # which is what the phenotype is associated with
                sex_qualified_genotype_id = \
                    self.make_id((
                        colony_id + phenotyping_center + zygosity +
                        strain_accession_id + sex))
                sex_qualified_genotype_label = genotype_name + ' (' + sex + ')'

                sq_type_id = self.resolve(sex, False)

                if sq_type_id == sex:
                    sq_type_id = self.globaltt['intrinsic_genotype']
                    LOG.warning(
                        "Unknown sex qualifier %s, adding as intrinsic_genotype",
                        sex)

                geno.addGenotype(
                    sex_qualified_genotype_id, sex_qualified_genotype_label, sq_type_id)
                geno.addParts(
                    genotype_id, sex_qualified_genotype_id,
                    self.globaltt['has_variant_part'])

                if genomic_background_id is not None and genomic_background_id != '':
                    # Add the taxon to the genomic_background_id
                    geno.addTaxon(taxon_id, genomic_background_id)
                else:
                    # add it as the genomic background
                    geno.addTaxon(taxon_id, genotype_id)

                # #############    BUILD THE G2P ASSOC    #############
                # from an old email dated July 23 2014:
                # Phenotypes associations are made to
                # imits colony_id+center+zygosity+gender

                phenotype_id = mp_term_id

                # it seems that sometimes phenotype ids are missing.
                # indicate here
                if phenotype_id is None or phenotype_id == '':
                    LOG.warning(
                        "No phenotype id specified for row %d: %s",
                        reader.line_num, str(row))
                    continue
                # hard coded ECO code
                eco_id = self.globaltt['mutant phenotype evidence']

                # the association comes as a result of a g2p from
                # a procedure in a pipeline at a center and parameter tested

                assoc = G2PAssoc(
                    graph, self.name, sex_qualified_genotype_id, phenotype_id)
                assoc.add_evidence(eco_id)
                # assoc.set_score(float(p_value))

                # TODO add evidence instance using
                # pipeline_stable_id +
                # procedure_stable_id +
                # parameter_stable_id

                assoc.add_association_to_graph()
                assoc_id = assoc.get_association_id()

                model._addSexSpecificity(assoc_id, self.resolve(sex))

                # add a free-text description
                try:
                    description = ' '.join((
                        mp_term_name, 'phenotype determined by', phenotyping_center,
                        'in an', procedure_name, 'assay where', parameter_name.strip(),
                        'was measured with an effect_size of',
                        str(round(float(effect_size), 5)),
                        '(p =', "{:.4e}".format(float(p_value)), ').'))
                except ValueError:
                    description = ' '.join((
                        mp_term_name, 'phenotype determined by', phenotyping_center,
                        'in an', procedure_name, 'assay where', parameter_name.strip(),
                        'was measured with an effect_size of', str(effect_size),
                        '(p =', "{0}".format(p_value), ').'))

                study_bnode = self._add_study_provenance(
                    phenotyping_center, colony_raw, project_fullname, pipeline_name,
                    pipeline_stable_id, procedure_stable_id, procedure_name,
                    parameter_stable_id, parameter_name, statistical_method,
                    resource_name)

                evidence_line_bnode = self._add_evidence(
                    assoc_id, eco_id, p_value, percentage_change, effect_size,
                    study_bnode)

                self._add_assertion_provenance(assoc_id, evidence_line_bnode)

                model.addDescription(evidence_line_bnode, description)

                # resource_id = resource_name
                # assoc.addSource(graph, assoc_id, resource_id)

                if not self.test_mode and limit is not None and reader.line_num > limit:
                    break

    def _add_assertion_provenance(
            self,
            assoc_id,
            evidence_line_bnode
    ):
        """
        Add assertion level provenance, currently always IMPC
        :param assoc_id:
        :param evidence_line_bnode:
        :return:
        """
        provenance_model = Provenance(self.graph)
        model = Model(self.graph)
        assertion_bnode = self.make_id(
            "assertion{0}{1}".format(assoc_id, self.localtt['IMPC']), '_')

        model.addIndividualToGraph(assertion_bnode, None, self.globaltt['assertion'])

        provenance_model.add_assertion(
            assertion_bnode, self.localtt['IMPC'],
            'International Mouse Phenotyping Consortium')

        self.graph.addTriple(
            assoc_id, self.globaltt['proposition_asserted_in'], assertion_bnode)

        self.graph.addTriple(
            assertion_bnode,
            self.resolve('is_assertion_supported_by_evidence'),  # "SEPIO:0000111"
            evidence_line_bnode)

    def _add_study_provenance(
            self,
            phenotyping_center,
            colony,
            project_fullname,
            pipeline_name,
            pipeline_stable_id,
            procedure_stable_id,
            procedure_name,
            parameter_stable_id,
            parameter_name,
            statistical_method,
            resource_name
    ):
        """
        :param phenotyping_center: str, from self.files['all']
        :param colony: str, from self.files['all']
        :param project_fullname: str, from self.files['all']
        :param pipeline_name: str, from self.files['all']
        :param pipeline_stable_id: str, from self.files['all']
        :param procedure_stable_id: str, from self.files['all']
        :param procedure_name: str, from self.files['all']
        :param parameter_stable_id: str, from self.files['all']
        :param parameter_name: str, from self.files['all']
        :param statistical_method: str, from self.files['all']
        :param resource_name: str, from self.files['all']
        :return: study bnode
        """

        provenance_model = Provenance(self.graph)
        model = Model(self.graph)

        # Add provenance
        # A study is a blank node equal to its parts
        study_bnode = self.make_id("{0}{1}{2}{3}{4}{5}{6}{7}".format(
            phenotyping_center, colony, project_fullname, pipeline_stable_id,
            procedure_stable_id, parameter_stable_id, statistical_method,
            resource_name), '_')

        model.addIndividualToGraph(
            study_bnode, None, self.globaltt['study'])

        # List of nodes linked to study with has_part property
        study_parts = []

        # Add study parts
        model.addIndividualToGraph(self.resolve(procedure_stable_id), procedure_name)
        study_parts.append(self.resolve(procedure_stable_id))

        study_parts.append(self.resolve(statistical_method))
        provenance_model.add_study_parts(study_bnode, study_parts)

        # Add parameter/measure statement: study measures parameter
        parameter_label = "{0} ({1})".format(parameter_name, procedure_name)

        logging.info("Adding Provenance")
        model.addIndividualToGraph(
            self.resolve(parameter_stable_id), parameter_label)
        provenance_model.add_study_measure(
            study_bnode, self.resolve(parameter_stable_id))

        # Add Colony
        colony_bnode = self.make_id("{0}".format(colony), '_')
        model.addIndividualToGraph(colony_bnode, colony)

        # Add study agent
        model.addIndividualToGraph(
            self.resolve(phenotyping_center), phenotyping_center,
            self.globaltt['organization'])

        # self.graph
        model.addTriple(
            study_bnode, self.globaltt['has_agent'], self.resolve(phenotyping_center))

        # add pipeline and project
        model.addIndividualToGraph(
            self.resolve(pipeline_stable_id), pipeline_name)

        # self.graph
        model.addTriple(
            study_bnode, self.globaltt['part_of'], self.resolve(pipeline_stable_id))

        model.addIndividualToGraph(
            self.resolve(project_fullname), project_fullname, self.globaltt['project'])

        # self.graph
        model.addTriple(
            study_bnode, self.globaltt['part_of'], self.resolve(project_fullname))

        return study_bnode

    def _add_evidence(
            self,
            assoc_id,
            eco_id,
            p_value,
            percentage_change,
            effect_size,
            study_bnode
    ):
        """
        :param assoc_id: assoc curie used to reify a
        genotype to phenotype association, generated in _process_data()
        :param eco_id: eco_id as curie, hardcoded in _process_data()
        :param p_value: str, from self.files['all']
        :param percentage_change: str, from self.files['all']
        :param effect_size: str, from self.files['all']
        :param study_bnode: str, from self.files['all']
        :param phenotyping_center: str, from self.files['all']
        :return: str, evidence_line_bnode as curie
        """

        evidence_model = Evidence(self.graph, assoc_id)
        provenance_model = Provenance(self.graph)
        model = Model(self.graph)

        # Add line of evidence
        evidence_line_bnode = self.make_id(
            "{0}{1}".format(assoc_id, study_bnode), '_')
        evidence_model.add_supporting_evidence(evidence_line_bnode)
        model.addIndividualToGraph(evidence_line_bnode, None, eco_id)

        # Add supporting measurements to line of evidence
        measurements = {}
        if p_value is not None or p_value != "":
            p_value_bnode = self.make_id(
                "{0}{1}{2}".format(evidence_line_bnode, 'p_value', p_value), '_')
            model.addIndividualToGraph(p_value_bnode, None, self.globaltt['p-value'])
            try:
                measurements[p_value_bnode] = float(p_value)
            except ValueError:
                measurements[p_value_bnode] = p_value
        if percentage_change is not None and percentage_change != '':

            fold_change_bnode = self.make_id(
                "{0}{1}{2}".format(
                    evidence_line_bnode, 'percentage_change', percentage_change), '_')
            model.addIndividualToGraph(
                fold_change_bnode, None, self.resolve('percentage_change'))
            measurements[fold_change_bnode] = percentage_change
        if effect_size is not None or effect_size != "":
            fold_change_bnode = self.make_id(
                "{0}{1}{2}".format(
                    evidence_line_bnode, 'effect_size', effect_size), '_')
            model.addIndividualToGraph(
                fold_change_bnode, None, self.globaltt['effect size estimate'])
            measurements[fold_change_bnode] = effect_size

        evidence_model.add_supporting_data(evidence_line_bnode, measurements)

        # Link evidence to provenance by connecting to study node
        provenance_model.add_study_to_measurements(study_bnode, measurements.keys())
        self.graph.addTriple(
            evidence_line_bnode, self.globaltt['has_supporting_activity'],
            study_bnode)

        return evidence_line_bnode

    def parse_checksum_file(self, file):
        """
        :param file
        :return dict

        """
        checksums = dict()
        file_path = '/'.join((self.rawdir, file))
        col = ['checksum', 'whitespace', 'file_name']
        with open(file_path, 'rt') as tsvfile:
            reader = csv.reader(tsvfile, delimiter=' ')
            for row in reader:
                checksums[row[col.index('checksum')]] = row[col.index('file_name')]
        return checksums

    def compare_checksums(self):
        """
        test to see if fetched file matches checksum from ebi
        :return: True or False

        """
        is_match = True
        reference_checksums = self.parse_checksum_file(
            self.files['checksum']['file'])
        for md5, file in reference_checksums.items():
            if os.path.isfile('/'.join((self.rawdir, file))):
                if self.get_file_md5(self.rawdir, file) != md5:
                    is_match = False
                    LOG.warning('%s was not downloaded completely', file)
                    return is_match

        return is_match

    def getTestSuite(self):
        import unittest
        from tests.test_impc import EvidenceProvenanceTestCase
        # TODO test genotypes

        test_suite = unittest.TestLoader().loadTestsFromTestCase(
            EvidenceProvenanceTestCase)

        return test_suite
